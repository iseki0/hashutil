package space.iseki.hashutil

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.serialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.util.HexFormat
import java.io.File
import java.io.InputStream
import java.nio.file.OpenOption
import java.nio.file.Path
import java.security.MessageDigest
import kotlin.io.path.inputStream


private fun getIntOffset(bytes: ByteArray, off: Int) = 0 or
        (bytes[0 + off].toInt() and 0xff shl 3 * 8) or
        (bytes[1 + off].toInt() and 0xff shl 2 * 8) or
        (bytes[2 + off].toInt() and 0xff shl 1 * 8) or
        (bytes[3 + off].toInt() and 0xff)

private fun putIntOffset(bytes: ByteArray, off: Int, value: Int) {
    bytes[0 + off] = (value shr 3 * 8).toByte()
    bytes[1 + off] = (value shr 2 * 8).toByte()
    bytes[2 + off] = (value shr 1 * 8).toByte()
    bytes[3 + off] = value.toByte()
}

private val hex = HexFormat.of()

private fun MessageDigest.hashStream(inputStream: InputStream): ByteArray {
    val buffer = ByteArray(4 * 1024)
    var read: Int
    while (inputStream.read(buffer).also { read = it } > -1) {
        update(buffer, 0, read)
    }
    return digest()
}
